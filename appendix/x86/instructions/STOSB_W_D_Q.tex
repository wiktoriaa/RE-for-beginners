\myindex{\CStandardLibrary!memset()}
\myindex{x86!\Instructions!STOSB}
\myindex{x86!\Instructions!STOSW}
\myindex{x86!\Instructions!STOSD}
\myindex{x86!\Instructions!STOSQ}
\item[STOSB/STOSW/STOSD/STOSQ] \RU{записать}\EN{store} \RU{байт}\EN{byte}/
16-\RU{битное слово}\EN{bit word}/
32-\RU{битное слово}\EN{bit word}/
64-\RU{битное слово}\EN{bit word} \RU{из}\EN{from} AX/EAX/RAX \RU{в место, адрес которого находится
в}\EN{into the address which is in} DI/EDI/RDI.

\label{REP_STOSx}
\myindex{x86!\Prefixes!REP}
\RU{Вместе с префиксом REP, инструкция будет исполняться в цикле, счетчик будет
находится в регистре CX/ECX/RCX}
\EN{Together with the REP prefix, it is to be repeated in a loop, the counter is in the CX/ECX/RCX register}:
\RU{это работает как}\EN{it works like} memset() \RU{в Си}\EN{in C}.
\RU{Если размер блока известен компилятору на стадии компиляции,
memset() часто компилируется в короткий фрагмент кода использующий
REP STOSx, иногда даже несколько инструкций}
\EN{If the block size is known to the compiler on compile stage, 
memset() is often inlined into a short code fragment
using REP MOVSx, sometimes even as several instructions}.

\myindex{\CStandardLibrary!memset()}
\RU{Эквивалент }memset(EDI, 0xAA, 15)\EN{ equivalent is}:

\EN{\lstinputlisting[style=customasmx86]{appendix/x86/instructions/STOSB_ex1_EN.asm}}
\RU{\lstinputlisting[style=customasmx86]{appendix/x86/instructions/STOSB_ex1_RU.asm}}

(\RU{Вероятно, так быстрее чем заполнять 15 байт используя просто одну REP STOSB}
\EN{Supposedly, it works faster than storing 15 bytes using just one REP STOSB}).

