\sectionold{Как это работает}

Вот как деление может быть заменено на умножение и деление на числа $2^{n}$:

\[
	result = 
	\frac{input}{divisor} = 
	\frac{input \cdot \frac{2^{n}}{divisor}}{2^{n}} = 
	\frac{input \cdot M}{2^{n}}
\]

Где $M$ это \IT{magic}-коэффициент.

Как вычислить $M$:

\[
	M = \frac{2^{n}}{divisor}
\]

Так что эти фрагменты кода обычно имеют форму:

\[
	result = \frac{input \cdot M}{2^{n}}
\]

Деление на $2^{n}$ производится обычным битовым сдвигом вправо.

Если $n\geq32$, то тогда сдвигается старшая часть \glslink{product}{произведения} (в \EDX или \RDX).

$n$ выбирается так, чтобы улучшить точность результата.

Если делать знаковое деление, знак результата умножения также добавляется к результату.

Посмотрите на разницу:

\begin{lstlisting}
int f3_32_signed(int a)
{
	return a/3;
};

unsigned int f3_32_unsigned(unsigned int a)
{
	return a/3;
};
\end{lstlisting}

В беззнаковой версии функции, \IT{magic}-коэффициент это \TT{0xAAAAAAAB} и результат умножения делится на $2^{33}$.

В знаковой версии функции, \IT{magic}-коэффициент это
 \TT{0x55555556} и результат умножения делится на $2^{32}$.
Впрочем здесь нет инструкции деления: результат просто берется из \EDX. 

Знак результата умножения также учитывается: старшие 32 бита результата сдвигаются на 31
(таким образом, оставляя знак в самом младшем бите \EAX).

1 прибавляется к конечному результату, если знак отрицательный, для коррекции результата.

\lstinputlisting[caption=\Optimizing MSVC 2012]{\CURPATH/2_RU.asm}

\subsectionold{Больше теории}

Это работает, потому что можно заменить деление на умножение вот так:

\[
	\frac{x}{c} = x\frac{1}{c}
\]


$\frac{1}{c}$ называется \IT{обратное число} и может быть предвычислено компилятором.

Но это для вещественных чисел.
Что насчет целых чисел?

Можно найти \IT{обратное число по модулю} для целого числа в среде модульной арифметики
\footnote{\href{http://go.yurichev.com/17359}{Wikipedia}}.

Регистры \ac{CPU} подходят идеально: каждый ограничен 32 или 64-ю битами, так что практически любая арифметическая операция над регистрами это на самом деле операции по модулю $2^{32}$ или $2^{64}$.

Читайте больше об этом в [\HenryWarren 10-3].
