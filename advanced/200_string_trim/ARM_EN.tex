\subsection{ARM: \OptimizingKeilVI (\ARMMode)}

And again, the compiler took advantage of ARM mode's conditional instructions, 
so the code is much more compact.

\lstinputlisting[caption=\OptimizingKeilVI (\ARMMode),style=customasmARM]{\CURPATH/Keil_ARM_O3_EN.s}

\subsection{ARM: \OptimizingKeilVI (\ThumbMode)}
\myindex{\CompilerAnomaly}
\label{Keil_anomaly}

There are less conditional instructions in Thumb mode, so the code is simpler.

But there are is really weird thing with the 0x20 and 0x1F offsets (lines 22 and 23).
Why did the Keil compiler do so?
Honestly, it's hard to say.

It has to be a quirk of Keil's optimization process.
Nevertheless, the code works correctly.

\lstinputlisting[caption=\OptimizingKeilVI (\ThumbMode),numbers=left,style=customasmARM]{\CURPATH/Keil_thumb_O3_EN.s}

