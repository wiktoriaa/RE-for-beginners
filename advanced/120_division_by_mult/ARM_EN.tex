\subsection{ARM}

The ARM processor, just like in any other \q{pure} RISC processor lacks an instruction for division.
It also lacks a single instruction for multiplication by a 32-bit constant (recall that a 32-bit
constant cannot fit into a 32-bit opcode).

By taking advantage of this clever trick (or \IT{hack}), it is possible to do division using only three instructions: addition,
subtraction and bit shifts~(\myref{sec:bitfields}).

Here is an example that divides a 32-bit number by 10, from
\InSqBrackets{\ARMCookBook 3.3 Division by a Constant}.
The output consists of the quotient and the remainder.

\begin{lstlisting}[style=customasmARM]
; takes argument in a1
; returns quotient in a1, remainder in a2
; cycles could be saved if only divide or remainder is required
    SUB    a2, a1, #10             ; keep (x-10) for later
    SUB    a1, a1, a1, lsr #2
    ADD    a1, a1, a1, lsr #4
    ADD    a1, a1, a1, lsr #8
    ADD    a1, a1, a1, lsr #16
    MOV    a1, a1, lsr #3
    ADD    a3, a1, a1, asl #2
    SUBS   a2, a2, a3, asl #1      ; calc (x-10) - (x/10)*10
    ADDPL  a1, a1, #1              ; fix-up quotient
    ADDMI  a2, a2, #10             ; fix-up remainder
    MOV    pc, lr
\end{lstlisting}

\subsubsection{\OptimizingXcodeIV (\ARMMode)}

\begin{lstlisting}[style=customasmARM]
__text:00002C58 39 1E 08 E3 E3 18 43 E3  MOV    R1, 0x38E38E39
__text:00002C60 10 F1 50 E7              SMMUL  R0, R0, R1
__text:00002C64 C0 10 A0 E1              MOV    R1, R0,ASR#1
__text:00002C68 A0 0F 81 E0              ADD    R0, R1, R0,LSR#31
__text:00002C6C 1E FF 2F E1              BX     LR
\end{lstlisting}

This code is almost the same as the one generated by the optimizing MSVC and GCC.

Apparently, LLVM uses the same algorithm for generating constants.

\myindex{ARM!\Instructions!MOV}
\myindex{ARM!\Instructions!MOVT}

The observant reader may ask, how does \MOV writes a 32-bit value in a register, when this is not possible in ARM mode.

it is impossible indeed, but, as we see,
there are 8 bytes per instruction instead of the standard 4,
in fact, there are two instructions.

The first instruction loads \TT{0x8E39} into the low 16 bits of register and the second instruction is
\TT{MOVT}, it loads \TT{0x383E} into the high 16 bits of the register.
\IDA is fully aware of such sequences, and for the sake of compactness reduces them to one single \q{pseudo-instruction}.

\myindex{ARM!\Instructions!SMMUL}
The \TT{SMMUL} (\IT{Signed Most Significant Word Multiply}) 
instruction two multiplies numbers, treating them as signed numbers
and leaving the high 32-bit part of result in the \Reg{0} register,
dropping the low 32-bit part of the result.

\myindex{ARM!Optional operators!ASR}
The\TT{\q{MOV R1, R0,ASR\#1}} instruction is an arithmetic shift right by one bit.

\myindex{ARM!\Instructions!ADD}
\myindex{ARM!Data processing instructions}
\myindex{ARM!Optional operators!LSR}
\TT{\q{ADD R0, R1, R0,LSR\#31}} is $R0=R1 + R0>>31$

% FIXME какие именно инструкции? \myref{} ->
\label{shifts_in_ARM_mode}

There is no separate shifting instruction in ARM mode.
Instead, an instructions like 
(\MOV, \ADD, \SUB, \TT{RSB})\footnote{\DataProcessingInstructionsFootNote}
can have a suffix added, that says if the second operand must be shifted, and if yes, by what value and how.
\TT{ASR} stands for \IT{Arithmetic Shift Right}, \TT{LSR}---\IT{Logical Shift Right}.

\subsubsection{\OptimizingXcodeIV (\ThumbTwoMode)}

\begin{lstlisting}[style=customasmARM]
MOV             R1, 0x38E38E39
SMMUL.W         R0, R0, R1
ASRS            R1, R0, #1
ADD.W           R0, R1, R0,LSR#31
BX              LR
\end{lstlisting}

\myindex{ARM!\Instructions!ASRS}

There are separate instructions for shifting in Thumb mode, 
and one of them is used here---\TT{ASRS} (arithmetic shift right).

\subsubsection{\NonOptimizing Xcode 4.6.3 (LLVM) and Keil 6/2013}

\NonOptimizing LLVM
does not generate the code we saw before in this section, but instead inserts a call to the library function 
\IT{\_\_\_divsi3}.

What about Keil: it inserts a call to the library function \IT{\_\_aeabi\_idivmod} in all cases.
