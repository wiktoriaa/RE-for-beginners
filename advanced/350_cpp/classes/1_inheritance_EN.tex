\subsubsection{Class inheritance}
\label{cpp_inheritance}


Inherited classes are similar to the simple structures we already discussed, but extended 
in inheritable classes.

Let's take this simple example:

\lstinputlisting[style=customc]{\CURPATH/classes/classes1_inheritance.cpp}


Let's investigate the generated code of the \TT{dump()} functions/methods and also \TT{object::print\_color()},
and see the memory layout for the structures-objects (for 32-bit code).

\myindex{Inline code}

So, here are the \TT{dump()} methods for several classes, generated by MSVC 2008 with \Ox and \Obzero options
\footnote{
The \Obzero option stands for disabling inline expansion since function inlining
can make our experiment harder}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0,style=customasmx86]{\CURPATH/classes/classes1_1.asm}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0,style=customasmx86]{\CURPATH/classes/classes1_2.asm}

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0,style=customasmx86]{\CURPATH/classes/classes1_3.asm}

So, here is the memory layout:

(base class \IT{object})

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
\hline
  +0x0 & int color \\
\hline
\end{tabular}
\end{center}

(inherited classes)

\IT{box}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
\hline
  +0x0 & int color \\
\hline
  +0x4 & int width \\
\hline
  +0x8 & int height \\
\hline
  +0xC & int depth \\
\hline
\end{tabular}
\end{center}

\IT{sphere}:

\begin{center}
\begin{tabular}{ | l | l | }
\hline
  \tableheader{} \\
\hline
  +0x0 & int color \\
\hline
  +0x4 & int radius \\
\hline
\end{tabular}
\end{center}

Let's see \main function body:

\lstinputlisting[caption=\Optimizing MSVC 2008 /Ob0,style=customasmx86]{\CURPATH/classes/classes1_4.asm}


The inherited classes must always add their fields after the base classes' fields, to make it possible for the base 
class methods to work with their own fields.


When the \TT{object::print\_color()} method is called, a pointers to both the \IT{box} and \IT{sphere} objects are passed as \TT{this},
and it can work with these objects easily since the \IT{color} field in these objects is always at the pinned address (at offset \IT{+0x0}).


It can be said that the \TT{object::print\_color()} method is agnostic in relation to the input object type as long as the fields are \IT{pinned}
at the same addresses, and this condition is always true.


And if you create inherited class of the \IT{box} class, 
the compiler will add the new fields after the \IT{depth} field,
leaving the \IT{box} class fields at the pinned addresses.


Thus, the \TT{box::dump()} method will work fine for accessing the 
\IT{color}, \IT{width}, \IT{height} and \IT{depths} fields, which are always pinned at known addresses.


The code generated by GCC is almost the same, with the sole exception of passing the \TT{this} pointer (as it has been explained above,
it is passed as the first argument instead of using the \ECX register.

