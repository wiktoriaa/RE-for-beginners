\myparagraph{32-bit ARM}

\mysubparagraph{\NonOptimizingXcodeIV (\ARMMode)}

\lstinputlisting[caption=\NonOptimizingXcodeIV (\ARMMode),label=ARM_leaf_example7,style=customasmARM]{patterns/10_strings/1_strlen/ARM/xcode_ARM_O0_EN.asm}

Non-optimizing LLVM generates too much code, however, here we can see how the function works with 
local variables in the stack.
There are only two local variables in our function: \IT{eos} and \IT{str}.
In this listing, generated by \IDA, we have manually renamed \IT{var\_8} and \IT{var\_4} to \IT{eos} and \IT{str}.

The first instructions just saves the input values into both \IT{str} and \IT{eos}.

The body of the loop starts at label \IT{loc\_2CB8}.

The first three instruction in the loop body (\TT{LDR}, \ADD, \TT{STR}) load the value of \IT{eos} into \Reg{0}. 
Then the value is \glslink{increment}{incremented} and saved back into \IT{eos}, which is located in the stack.

\myindex{ARM!\Instructions!LDRSB}
The next instruction,  \TT{LDRSB R0, [R0]} (\q{Load Register Signed Byte}), loads a byte from memory at the address stored in \Reg{0} and sign-extends it to 32-bit
\footnote{The Keil compiler treats the \Tchar type as signed, just like MSVC and GCC.}.
\myindex{x86!\Instructions!MOVSX}
This is similar to the \MOVSX instruction in x86.

The compiler treats this byte as signed since the \Tchar type is signed according to the C standard.
It was already written about it~(\myref{MOVSX}) in this section, in relation to x86.

\myindex{Intel!8086}
\myindex{Intel!8080}
\myindex{ARM}

It has to be noted that it is impossible to use 8- or 16-bit part 
of a 32-bit register in ARM separately of the whole register,
as it is in x86.

Apparently, it is because x86 has a huge history of backwards compatibility with its ancestors 
up to the 16-bit 8086 and even 8-bit 8080,
but ARM was developed from scratch as a 32-bit RISC-processor.

Consequently, in order to process separate bytes in ARM, one has to use 32-bit registers anyway.

So, \TT{LDRSB} loads bytes from the string into \Reg{0}, one by one.
The following \CMP and \ac{BEQ} instructions check if the loaded byte is 0.
If it's not 0, control passes to the start of the body of the loop.
And if it's 0, the loop ends.

At the end of the function, the difference between 
\IT{eos} and \IT{str} is calculated, 1 is subtracted from it, and resulting value is returned
via \Reg{0}.

N.B. Registers were not saved in this function.
\myindex{ARM!\Registers!scratch registers}

That's because in the ARM calling convention registers \Reg{0}-\Reg{3} are \q{scratch registers}, 
intended for arguments passing,
and we're not required to restore their value when the function exits, 
since the calling function will not use them anymore.
Consequently, they may be used for anything we want.

No other registers are used here, so that is why we have nothing to save on the stack.

Thus, control may be returned back to calling function by a simple jump (\TT{BX}),
to the address in the \ac{LR} register.

\mysubparagraph{\OptimizingXcodeIV (\ThumbMode)}

\lstinputlisting[caption=\OptimizingXcodeIV (\ThumbMode),style=customasmARM]{patterns/10_strings/1_strlen/ARM/xcode_thumb_O3.asm}

As optimizing LLVM concludes, \IT{eos} and \IT{str} do not need space on the stack, and can always be stored in registers.

Before the start of the loop body, \IT{str} is always in \Reg{0}, 
and \IT{eos}---in \Reg{1}.

\myindex{ARM!\Instructions!LDRB.W}
The \TT{LDRB.W R2, [R1],\#1} instruction loads a byte from the memory at the address stored in \Reg{1}, to \Reg{2}, sign-extending it to a 32-bit value, but not just that.
\TT{\#1} at the instruction's end is implies \q{Post-indexed addressing}, which means that 1 is to be added to \Reg{1} after the byte is loaded.
Read more about it: \myref{ARM_postindex_vs_preindex}.

Then you can see \CMP and \ac{BNE} in the body of the loop, these instructions continue looping until 0 is found in the string.

\myindex{ARM!\Instructions!MVNS}
\myindex{x86!\Instructions!NOT}
\TT{MVNS}\footnote{MoVe Not} (inverts all bits, like \NOT in x86) and \ADD instructions compute $eos - str - 1$.
In fact, these two instructions compute $R0 = ~str + eos$, 
which is effectively equivalent to what was in the source code, and why it is so, was already explained here
~(\myref{strlen_NOT_ADD}).

Apparently, LLVM, just like GCC, concludes that this code can be shorter (or faster).

\mysubparagraph{\OptimizingKeilVI (\ARMMode)}

\lstinputlisting[caption=\OptimizingKeilVI (\ARMMode),label=ARM_leaf_example6,style=customasmARM]{patterns/10_strings/1_strlen/ARM/Keil_ARM_O3.asm}

\myindex{ARM!\Instructions!SUBEQ}

Almost the same as what we saw before, with the exception that the $str - eos - 1$ 
expression can be computed not at the function's end, but right in the body of the loop.
The \TT{-EQ} suffix, as we may recall, implies that the instruction executes only if the operands in
the \CMP that has been executed before were equal to each other.
Thus, if \Reg{0} contains 0, both \TT{SUBEQ} instructions executes and result is left in the \Reg{0} register.

