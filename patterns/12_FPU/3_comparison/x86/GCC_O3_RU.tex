\myparagraph{\Optimizing GCC 4.4.1}

\lstinputlisting[caption=\Optimizing GCC 4.4.1,style=customasmx86]{patterns/12_FPU/3_comparison/x86/GCC_O3_RU.asm}

\myindex{x86!\Instructions!JA}

Почти всё что здесь есть, уже описано мною, кроме одного: использование \JA после \SAHF. 
Действительно, инструкции условных переходов \q{больше}, \q{меньше} и \q{равно} для сравнения беззнаковых чисел 
(а это \JA, \JAE, \JB, \JBE, \JE/\JZ, \JNA, \JNAE, \JNB, \JNBE, \JNE/\JNZ) проверяют только флаги \CF и \ZF.\\
\\
Вспомним, как биты \CThreeBits располагаются в регистре \GTT{AH} после исполнения \INS{FSTSW}/\FNSTSW:

\input{C3_in_AH}

Вспомним также, как располагаются биты из \GTT{AH} во флагах CPU после исполнения \SAHF:

\input{SAHF_LAHF}

Биты \Cthree и \Czero после сравнения перекладываются в флаги \ZF и \CF так, что перечисленные инструкции переходов могут работать. \JA сработает, если \CF и \ZF обнулены.

Таким образом, перечисленные инструкции условного перехода можно использовать после инструкций \FNSTSW/\SAHF.

Может быть, биты статуса FPU \CThreeBits преднамеренно были размещены таким образом, чтобы переноситься на базовые флаги процессора без перестановок?

