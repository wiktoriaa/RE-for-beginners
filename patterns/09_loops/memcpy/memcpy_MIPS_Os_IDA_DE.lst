my_memcpy:
<<<<<<< HEAD
; springe zum Prüfen der Schleifenbedingung:
                b       loc_14
; initialisiere Zähler (i) mit 0
=======
; springe zum PrÃ¼fen der Schleifenbedingung:
                b       loc_14
; initialisiere ZÃ¤hler (i) mit 0
>>>>>>> 33058039def6268466867db95246998137625356
; bleibt stets in $v0:
                move    $v0, $zero ; branch delay slot

loc_8:                                   # CODE XREF: my_memcpy+1C
; lade unsigned Byte von $t0 nach $v1:
                lbu     $v1, 0($t0)
<<<<<<< HEAD
; erhöhe Zähler (i):
=======
; erhÃ¶he ZÃ¤hler (i):
>>>>>>> 33058039def6268466867db95246998137625356
                addiu   $v0, 1
; speichere Byte an der Stelle $a3
                sb      $v1, 0($a3)

loc_14:                                  # CODE XREF: my_memcpy
<<<<<<< HEAD
; prüfe, ob Zähler (i) in $v0 immer noch kleiner ist als das dritte
=======
; prÃ¼fe, ob ZÃ¤hler (i) in $v0 immer noch kleiner ist als das dritte
>>>>>>> 33058039def6268466867db95246998137625356
Funktionsargument ("cnt" in $a2):
                sltu    $v1, $v0, $a2
; Byteadresse in Quellblock bilden:
                addu    $t0, $a1, $v0
; $t0 = $a1+$v0 = src+i
<<<<<<< HEAD
; springe zum Schleifenkörper, falls der Zähler immer noch kleiner ist als
=======
; springe zum SchleifenkÃ¶rper, falls der ZÃ¤hler immer noch kleiner ist als
>>>>>>> 33058039def6268466867db95246998137625356
"cnt":
                bnez    $v1, loc_8
; Byteadresse im Zielblock bilden ($a3 = $a0+$v0 = dst+i):
                addu    $a3, $a0, $v0 ; branch delay slot
; beenden, falls BNEZ nicht getriggert wurde:
                jr      $ra
                or      $at, $zero ; branch delay slot, NOP
