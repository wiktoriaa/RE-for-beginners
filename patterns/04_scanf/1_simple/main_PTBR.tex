% TODO resync with EN version
\subsection{Exemplo simples}

\lstinputlisting[style=customc]{patterns/04_scanf/1_simple/ex1.c}

Não é muito inteligente usar scanf() para interações com o usuário nos dias de hoje.
Mas nós podemos, de qualquer maneira, ilustrar passando um ponteiro para uma variável do tipo \Tint.

\subsubsection{Sobre ponteiros}
\myindex{\CLanguageElements!\Pointers}

Ponteiros são um dos conceitos mais fundamentais na ciência da computação.
Com frequência, passar um array grande, estrutura ou objeto como um argumento para outra função é muito custoso, enquanto passar o endereço de onde ele está é bem mais rápido e gasta menos recursos.
Ainda mais se a função chamada precisa modificar alguma coisa em um array grande ou estrutura recebida como parâmetro e retornar de volta a estrutura inteira se torna perto de absurdo fazer dessa maneira.
Então a coisa mais simples a se fazer é passar o endereço do array ou estrutura para a função chamada e deixar ela fazer as mudanças necessárias.

Um ponteiro em \CCpp é somente um endereço de alguma localização de memória.

\myindex{x86-64}
Em x86, o endereço é representado como um número de 32-bits (ele ocupa 4 bytes), enquanto no x86-64 é um número de 64-bits (ocupando 8 bytes).
A propósito, essa é a razão da indignação de algumas pessoas em relação a trocar para x86-64 todos os ponteiros na arquitetura x64, exigindo o dobro de espaço, incluindo memória cache, que é um lugar ``caro''.

% TODO ... а делать разные версии memcpy для разных типов - абсурд
\myindex{\CStandardLibrary!memcpy()}
É possível ainda se trabalhar com ponteiros sem tipos, como a função padrão em C \TT{memcpy()}, que copia um block de uma localização de memória para outro,
ela recebe como argumento dois ponteiros do tipo void*, uma vez que é impossível de se prever o tipo de informação que você gostaria de copiar.
Tipos não são importantes, só o tamanho do bloco de memória é que importa.

Ponteiros são também largamente usados quando uma função precisa retornar mais de um valor
(nós vamos voltar nisso depois)
~(\myref{label_pointers})
).

\IT{scanf()} é um desses casos.

Além do fato de que a função precisa indicar quantos valores foram lidos com sucesso, ela também precisa retornar todos esses valores.

Em \CCpp os tipos dos ponteiros só são necessários para checagem em tempo de compilação.

Internamente, no código compilado não tem nenhuma informação sobre os tipos de cada ponteiro.
% TODO это сильно затрудняет декомпиляцию

\input{patterns/04_scanf/1_simple/x86}
\input{patterns/04_scanf/1_simple/x64}
\input{patterns/04_scanf/1_simple/ARM}
\input{patterns/04_scanf/1_simple/MIPS/main}
