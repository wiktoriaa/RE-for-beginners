\subsection{Prosty przykład}

\lstinputlisting[style=customc]{patterns/04_scanf/1_simple/ex1.c}

Teraz używanie \scanf do interakcji z użytkownikiem w programach nie jest zbyt popularne, jednak mimo wszystko funkcja ta jest dobrym przykładem użycia wskaźnika na zmienną typu  \Tint.

\subsubsection{O wskaźnikach}
\myindex{\CLanguageElements!\Pointers}

Wskaźniki są jedną z podstawowych koncepcji informatycznych. Często tworząc dużą tablicę, strukturę albo objekt jako argument jakiejś funkcji, przekazywanie wskaźnika do argumentu jest mniej pamięciożerne niż gdyby przekazać całą tablicę/strukturę, np. kiedy chcesz wypisać tekst w konsoli, najprościej będzie wskazać jego adres w pamięci.

W dodatku jeśli wywoływana funkcja potrzebuje zmodyfikować cokolwiek w dużej tablicy lub strukturze danych przekazanej jako parametr i zwrócić potem tą tablicę/strukturę, kopiowanie tylu danych byłoby prawie absurdalne. Dlatego najprościej będzie przekazać adres tej tablicy/struktury do wywoływanej funkcji i wtedy zmodyfikować to co wymagało modyfikacji.

Wskaźnik w \CCpp---jest adresem pewnego miejsca w pamięci.

\myindex{x86-64}
W x86, adresy są reprezentowane przy pomocy 32-bitowych liczb (czyli 4 bajtowych), a w x86-64 jako liczby 64-bitowe (czyli 8 bajtowe). Przy okazji jest to powód dlaczego niektórych ludzi oburza przeskok na x86-64- wszystkie wskaźniki w architekturze x64 wymagają dwa razy więcej miejsca, włączając pamięć cache, co jest bardzo "kosztownym" zużyciem pamięci.

% TODO ... а делать разные версии memcpy для разных типов - абсурд
\myindex{\CStandardLibrary!memcpy()}
Możliwa jest praca z tylko nietypowanymi wskaźnikami, wymagająca nieco wysiłku, np. funkcja z biblioteki standardowej C-\TT{memcpy()}, która kopiuje blok z jednej lokalizacji w pamięci do innej, jako argumenty przyjmuje 2 wskaźniki typu \TT{void*}, co umożliwia kopiowanie dowolnych typów danych. Typy danych nie są istotne, znaczenie mają tylko rozmiary bloków pamięci.

Wskaźniki są także często używane kiedy funkcja potrzebuje zwrócić więcej niż jedną wartość (wrócę do tego później
~(\myref{label_pointers})
).

Funkcja \IT{scanf()} jest takim przypadkiem.

Oprócz tego faktu, funkcja scanf() wymaga podania w argumencie ile wartości ma wczytać, żeby później móc je zwrócić.

W \CCpp typ wskaźnika jest potrzebny tylko do sprawdzania typów podczas kompilacji.

Wewnątrz skompilowanego kodu nie ma żadnej informacji jakiego typu są wskaźniki.
% TODO это сильно затрудняет декомпиляцию

\input{patterns/04_scanf/1_simple/x86}
\input{patterns/04_scanf/1_simple/x64}
\input{patterns/04_scanf/1_simple/ARM}
\input{patterns/04_scanf/1_simple/MIPS/main}
