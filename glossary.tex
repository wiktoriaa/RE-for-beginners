\newglossaryentry{tail call}
{
  name=\RU{хвостовая рекурсия}\EN{tail call}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}\FR{tail call},
  description={\RU{Это когда компилятор или интерпретатор превращает рекурсию 
  (с которой возможно это проделать, т.е. \IT{хвостовую}) в итерацию для эффективности}
  \EN{It is when the compiler (or interpreter) transforms the recursion (with which it is possible: \IT{tail recursion}) 
  into an iteration for efficiency}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{C'est lorsque le compilateur (ou l'interpréteur) transforme la récursion (ce qui est possible: \IT{tail recursion})
  en une itération pour l'efficacité}: \href{http://go.yurichev.com/17105}{wikipedia}}
}

\newglossaryentry{endianness}
{
  name=endianness,
  description={\RU{Порядок байт}\EN{Byte order}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}\FR{Ordre des octets}: \myref{sec:endianness}}
}

\newglossaryentry{caller}
{
  name=caller,
  description={\RU{Функция вызывающая другую функцию}\EN{A function calling another}\ESph{}\PTBRph{}\DE{aufrufende Funktion}\PLph{}\ITAph{}
  \FR{Une fonction en appelant une autre}}
}

\newglossaryentry{callee}
{
  name=callee,
  description={\RU{Вызываемая функция}\EN{A function being called by another}\ESph{}\PTBRph{}\DE{aufgerufene Funktion}\PLph{}\ITAph{}
  \FR{Une fonction appelée par une autre}}
}

\newglossaryentry{debuggee}
{
  name=debuggee,
  description={\RU{Отлаживаемая программа}\EN{A program being debugged}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Un programme en train d'être débogué}}
}

\newglossaryentry{leaf function}
{
  name=leaf function,
  description={\RU{Функция не вызывающая больше никаких функций}
  \EN{A function which does not call any other function}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Une fonction qui n'appelle pas d'autre fonction}}
}

\newglossaryentry{link register}
{
  name=link register,
  description=(RISC) {\RU{Регистр в котором обычно записан адрес возврата.
  Это позволяет вызывать leaf-функции без использования стека, т.е. быстрее}
  \EN{A register where the return address is usually stored.
  This makes it possible to call leaf functions without using the stack, i.e., faster}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Un registre oú l'adresse de retour est en général stockée. Ceci permet
  d'appeler une fonction leaf sans utiliser la pile, i.e, plus rapidemment}
  }
}

\newglossaryentry{anti-pattern}
{
  name=anti-pattern,
  description={\RU{Нечто широко известное как плохое решение}
  \EN{Generally considered as bad practice}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{En général considéré comme une mauvaise pratique}
  }
}

\newglossaryentry{stack pointer}
{
  name=\RU{указатель стека}\EN{stack pointer}\FR{pointeur de pile}\ESph{}\PTBRph{}\DE{Stapel-Zeiger}\PLph{}\ITAph{},
  description={\RU{Регистр указывающий на место в стеке}
  \EN{A register pointing to a place in the stack}\FR{Un registre qui pointe dans la pile}\ESph{}\PTBRph{}\DE{Ein Register das auf eine Stelle im Stack zeigt}\PLph{}\ITAph{}}
}

\newglossaryentry{decrement}
{
  name=\RU{декремент}\EN{decrement}\FR{décrémenter}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{},
  description={\RU{Уменьшение на 1}\EN{Decrease by 1}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Décrémenter de 1}
  }
}

\newglossaryentry{increment}
{
  name=\RU{инкремент}\EN{increment}\FR{incrémenter}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{},
  description={\RU{Увеличение на 1}\EN{Increase by 1}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Incrémenter de 1}
  }
}

\newglossaryentry{loop unwinding}
{
  name=loop unwinding,
  description={\RU{Это когда вместо организации цикла на $n$ итераций, компилятор генерирует $n$ копий тела
  цикла, для экономии на инструкциях, обеспечивающих сам цикл}
  \EN{It is when a compiler, instead of generating loop code for $n$ iterations, generates just $n$ copies of the
  loop body, in order to get rid of the instructions for loop maintenance}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{C'est lorsqu'un compilateur, au lieu de générer du code pour une boucle de
  $n$ itérations, génère juste $n$ copies du corps de la boucle, afin de supprimer
  les instructions pour la gestion de la boucle}
  }
}

\newglossaryentry{register allocator}
{
  name=register allocator,
  description={\RU{Функция компилятора распределяющая локальные переменные по регистрам процессора}
  \EN{The part of the compiler that assigns CPU registers to local variables}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{La partie du compilateur qui assigne des registes du CPU aux variables locales}}
}

\newglossaryentry{quotient}
{
  name=\RU{частное}\EN{quotient}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}\FR{quotient},
  description={\RU{Результат деления}\EN{Division result}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Résultat de la division}}
}

\newglossaryentry{product}
{
  name=\RU{произведение}\EN{product}\ESph{}\PTBRph{}\DE{Produkt}\PLph{}\ITAph{}\FR{produit},
  description={\RU{Результат умножения}\EN{Multiplication result}\ESph{}\PTBRph{}\DE{Ergebnis einer Multiplikation}\PLph{}\ITAph{}
  \FR{Résultat d'une multiplication}}
}

\newglossaryentry{NOP}
{
  name=NOP,
  description={\q{no operation}, \RU{холостая инструкция}\EN{idle instruction}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{instruction ne faisant rien}}
}

\newglossaryentry{POKE}
{
  name=POKE,
  description={\RU{Инструкция языка BASIC записывающая байт по определенному адресу}
  	\EN{BASIC language instruction for writing a byte at a specific address}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
    \FR{instruction du langage BASIC pour écrire un octet a une adresse spécifique}}
}

\newglossaryentry{keygenme}
{
  name=keygenme,
  description={\RU{Программа, имитирующая защиту вымышленной программы, для которой нужно сделать 
  генератор ключей/лицензий}\EN{A program which imitates software protection,
  for which one needs to make a key/license generator}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Un programme qui imite la protection des logiciels pour lesquels on a besoin d'un générateur de clef/licence}}
} % TODO clarify: A software which generate key/license value to bypass sotfware protection?

\newglossaryentry{dongle}
{
  name=dongle,
  description={\RU{Небольшое устройство подключаемое к LPT-порту для принтера (в прошлом) или к USB}
  \EN{Dongle is a small piece of hardware connected to LPT printer port (in past) or to USB}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Un dongle est un petit périphérique se connectant sur un port d'imprimante LPT (par le passé) ou USB}.
  \RU{Исполняло функции security token-а, имела память и, иногда,
  секретную (крипто-)хеширующую функцию}\EN{Its function was similar to a security token, 
  it has some memory and, sometimes, a secret (crypto-)hashing algorithm}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}i
  \FR{Sa fonction est similaire au tokens de sécurité, il y a de la mémoire et, parfois, un algorithme secret de (crypto-)hachage.}}
}

\newglossaryentry{thunk function}
{
  name=thunk function,
  description={\RU{Крохотная функция делающая только одно: вызывающая другую функцию}
  \EN{Tiny function with a single role: call another function}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Minuscule fonction qui a un seul rôle: appeler une autre fonction}}
}

\newglossaryentry{user mode}
{
  name=user mode,
  description={\RU{Режим CPU с ограниченными возможностями в котором он исполняет прикладное ПО. ср.}
  \EN{A restricted CPU mode in which it all application software code is executed. cf.}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Un mode CPU restreint dans lequel tout le code des applications est exécuté. cf.} \gls{kernel mode}}
}

\newglossaryentry{kernel mode}
{
  name=kernel mode,
  description={\RU{Режим CPU с неограниченными возможностями в котором он исполняет ядро OS и драйвера. ср.}
  \EN{A restrictions-free CPU mode in which the OS kernel and drivers execute. cf.}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Un mode CPU sans restriction dans lequel le noyaux de l'OS et les drivers sont exécutés. cf.} \gls{user mode}}
}

\newglossaryentry{Windows NT}
{
  name=Windows NT,
  description={Windows NT, 2000, XP, Vista, 7, 8, 10}
}

\newglossaryentry{atomic operation}
{
  name=atomic operation,
  description={
  \q{$\alpha{}\tau{}o\mu{}o\varsigma{}$}
  %\q{atomic}
  \RU{означает \q{неделимый} в греческом языке, так что атомарная операция ---
  это операция которая гарантированно не будет прервана другими тредами}
  \EN{stands for \q{indivisible} in Greek, so an atomic operation is guaranteed not
  to be interrupted by other threads}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{signifie \q{indivisible} en grec, donc il est garantie qu'une opération atomique ne sera pas interrompue par d'autres threads}
  }
}

% to be proofreaded (begin)
\newglossaryentry{NaN}
{
  name=NaN,
  description={
  	\RU{не число: специальные случаи чисел с плавающей запятой, 
  	обычно сигнализирующие об ошибках}\EN{not a number: 
  	a special cases for floating point numbers, usually signaling about errors}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
    \FR{pas un nombre: nu cas particulier pour les nombres flottants, signifiant généralement une erreur}
  }
}

\newglossaryentry{basic block}
{
  name=basic block,
  description={
  	\RU{группа инструкций, не имеющая инструкций переходов,
	а также не имеющая переходов в середину блока извне.
	В \IDA он выглядит как просто список инструкций без строк-разрывов}\EN{a group of 
	instructions that do not have jump/branch instructions, and also don't have
	jumps inside the block from the outside.
	In \IDA it looks just like as a list of instructions without empty lines}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  }
}

\newglossaryentry{NEON}
{
  name=NEON,
  description={\ac{AKA} \q{Advanced SIMD}\EMDASH\ac{SIMD} \RU{от}\EN{from}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}\FR{de} ARM}
}

\newglossaryentry{reverse engineering}
{
  name=reverse engineering,
  description={\RU{процесс понимания как устроена некая вещь, иногда, с целью клонирования оной}
  \EN{act of understanding how the thing works, sometimes in order to clone it}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{action d'examiner et de comprendre comment quelque chose fonctionne, parfois dans le but de le reproduire}
  }
}

\newglossaryentry{compiler intrinsic}
{
  name=compiler intrinsic,
  description={\RU{Специфичная для компилятора функция не являющаяся обычной библиотечной функцией.
	Компилятор вместо её вызова генерирует определенный машинный код.
	Нередко, это псевдофункции для определенной инструкции \ac{CPU}. Читайте больше:}
	\EN{A function specific to a compiler which is not an usual library function.
	The compiler generates a specific machine code instead of a call to it.
	Often, it's a pseudofunction for a specific \ac{CPU} instruction. Read more:}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
    \FR{Une foncion spécifique à un compilateur, qui n'est pas une fonction usuelle de bibliothèquee.
    Le compilateur génère du code machine spcifique au lieu d'un appel à celui-ci.
    Souvent il s'agit d'une pseudo-fonction pour une instruction \ac{CPU} spécifique. Lire plus:} (\myref{sec:compiler_intrinsic})
  }
}

\newglossaryentry{heap}
{
  name=\RU{heap}\EN{heap}\FR{tas},
  description={\RU{(куча) обычно, большой кусок памяти предоставляемый \ac{OS}, так что прикладное ПО может делить его
  как захочет. malloc()/free() работают с кучей}
  \EN{usually, a big chunk of memory provided by the \ac{OS} so that applications can divide it by themselves as they wish.
  malloc()/free() work with the heap}\FR{Généralement c'est un gros bout de mémoire fournit par l'\ac{OS} et utilisé par
  les applications pour le diviser comme elles le souhaitent. malloc()/free() fonctionnent en utilisant le tas}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}}
}

\newglossaryentry{name mangling}
{
  name=name mangling,
  description={\RU{применяется как минимум в \Cpp, где компилятору нужно закодировать имя класса,
  метода и типы аргументов в одной
  строке, которая будет внутренним именем функции. читайте также здесь}
  \EN{used at least in \Cpp, where the compiler needs to encode the name of class, method and argument types in one string,
  which will become the internal name of the function. You can read more about it here}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{utilisé au moins en \Cpp, oú le compilateur doit encoder le nom de la classe, la méthode et le type des arguments dans un chaîne,
  qui devient le nom interne de la fonction. Vous pouvez en lire plus à ce propos ici}: \myref{namemangling}}
}

\newglossaryentry{xoring}
{
  name=xoring,
  description={\RU{нередко применяемое в английском языке, означает применение операции 
  \ac{XOR}}
  \EN{often used in the English language, which implying applying the \ac{XOR} operation}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{souvent utilisé en angalis, qui signifie appliquer l'opération \ac{XOR}}
  }
}

\newglossaryentry{security cookie}
{
  name=security cookie,
  description={\RU{Случайное значение, разное при каждом исполнении. Читайте больше об этом тут}
  \EN{A random value, different at each execution. You can read more about it here}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Une valeur aléatoire, différente à chaque exécution. Vous pouvez en lire plus à ce propos ici}: \myref{subsec:BO_protection}}
}

\newglossaryentry{tracer}
{
  name=tracer,
  description={\RU{Моя простейшая утилита для отладки. Читайте больше об этом тут}
  \EN{My own simple debugging tool. You can read more about it here}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Mon propre outil de debugging. Vous pouvez en lire plus à son propos ici}: \myref{tracer}}
}

\newglossaryentry{GiB}
{
  name=GiB,
  description={\RU{Гибибайт: $2^{30}$ или 1024 мебибайт или 1073741824 байт}
  \EN{Gibibyte: $2^{30}$ or 1024 mebibytes or 1073741824 bytes}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Gibioctet: $2^{30}$ or 1024 mebioctets ou 1073741824 octets} %TODO: translate byte?
  }
}

\newglossaryentry{CP/M}
{
  name=CP/M,
  description={Control Program for Microcomputers: \RU{очень простая дисковая \ac{OS} использовавшаяся перед}
  \EN{a very basic disk \ac{OS} used before}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{un \ac{OS} de disque trè basique utilisé avant} MS-DOS}
}

\newglossaryentry{stack frame}
{
  name=stack frame,
  description={\RU{Часть стека, в которой хранится информация, связанная с текущей функцией: локальные переменные,
  аргументы функции, \ac{RA}, итд.}\EN{A part of the stack that contains information specific to the current function:
  local variables, function arguments, \ac{RA}, etc.}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Une partie de la pile qui contient des informations spécifiques à la fonction courante:
  variables locales, arguments de la fonciton, \ac{RA}, etc.}
  }
}

\newglossaryentry{jump offset}
{
  name=jump offset,
  description={\RU{Часть опкода JMP или Jcc инструкции, просто прибавляется к адресу следующей инструкции,
  и так вычисляется новый \ac{PC}. Может быть отрицательным}\EN{a part of the JMP or Jcc instruction's opcode, 
  to be added to the address
  of the next instruction, and this is how the new \ac{PC} is calculated. May be negative as well}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{une partie de l'opcode de l'instruction JMP ou Jcc, qui doit être ajoutée à l'adresse de l'instruction suivante,
  et c'est ainsi que le nouveau \ac{PC} est calculé. Peut-être négatif}
  }
}

\newglossaryentry{integral type}
{
  name=\RU{интегральный тип данных}\EN{integral data type}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{},
  description={\RU{обычные числа, но не вещественные. могут использоваться для передачи булевых типов и перечислений (enumerations)}
  \EN{usual numbers, but not a real ones. may be used for passing variables of boolean data type and enumerations}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{nombre usuel, mais pas un réel. peut être utilisé pour passer des variables de type booléen et des énumérations}
  }
}

\newglossaryentry{real number}
{
  name=\RU{вещественное число}\EN{real number}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{},
  description={\RU{числа, которые могут иметь точку. в \CCpp это \Tfloat и \Tdouble}
  \EN{numbers which may contain a dot. this is \Tfloat and \Tdouble in \CCpp}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{nombre qui peut contenir un point. ceci est \Tfloat et \Tdouble en \CCpp}
  }
}

\newglossaryentry{PDB}
{
  name=PDB,
  description={(Win32) \RU{Файл с отладочной информацией, обычно просто имена функций, 
  но иногда имена аргументов функций и локальных переменных}
  \EN{Debugging information file, usually just function names, but sometimes also function
  arguments and local variables names}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Fichier contenant des informations de débogage, en général seulement les noms des fonctions,
  mais aussi parfois les arguments des fonctions et le nom des variables locales}
  }
}

\newglossaryentry{NTAPI}
{
  name=NTAPI,
  description={\RU{\ac{API} доступное только в линии Windows NT. 
  Большей частью не документировано Microsoft-ом}\EN{\ac{API} available only in the Windows NT line. 
  Largely not documented by Microsoft}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{i\ac{API} disponible seulement dans la série de Windows NT. Très peu documentée par Microsoft}}
}

\newglossaryentry{stdout}
{
  name=stdout,
  description={standard output}
}

\newglossaryentry{word}
{
  name=word,
  description={\EN{data type fitting in \ac{GPR}}\RU{(слово) тип данных помещающийся в \ac{GPR}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}}. 
  \RU{В компьютерах старше персональных, память часто измерялась не в байтах, 
  а в словах}\EN{In the computers older than PCs, 
  the memory size was often measured in words rather than bytes}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{Dans les ordinateurs plus vieux que les PCs, la taille de la mémoire était
  souvent mesurée en mots plutôt qu'en octet}}
}

\newglossaryentry{arithmetic mean}
{
  name=\RU{среднее арифметическое}\EN{arithmetic mean}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}\FR{moyenne arithmétique},
  description={\EN{a sum of all values divided by their count}
  \RU{сумма всех значений, разделенная на их количество}\ESph{}\PTBRph{}\DEph{}\PLph{}\ITAph{}
  \FR{la somme de toutes les valeurs, divisé par leur nombre}}
}
\newglossaryentry{padding}
{
  name=padding,
  description=
  \EN{\IT{Padding} in English language means to stuff a pillow with something
  to give it a desired (bigger) form.
  In computer science, padding means to add more bytes to a block so it will have desired size, like $2^n$ bytes.}
  \RU{\IT{Padding} в английском языке означает набивание подушки чем-либо для придания ей желаемой (большей)
  формы. В информатике, \IT{padding} означает добавление к блоку дополнительных байт, чтобы он имел нужный
  размер, например, $2^n$ байт.}
  \FR{\IT{Padding} en anglais signifie rembourrer un oreiller, un matelat, etc. avec quelque chose afin de lui donner la forme désirée.
  En informatique, padding signifie ajouter des octets à un bloc, afin qu'il ait une certaine taille, comme $2^n$ octets.}
}

